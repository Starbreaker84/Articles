Итак, у нас есть универсальное определение зависимости:

**Свойство P, определяемое в некоторой вычислительной модели, зависит от компонента A тогда и только тогда, когда A - фактическая причина P (относительно пространства допустимых изменений A)**.

Рассмотрим теперь в его свете 9 типов зависимостей (см. первый материал по этой теме), причём в некоторых случаях мы получим ответ вида "это не зависимость, но часть зависимости".

**1. Зависимость фреймворка**.

Путаницу разрешает вопрос о зависимости конкретного свойства - а что конкретно зависит? Действительно, поведение планировщика раунд-робин (особенно время) во время его работы зависит от планируемых задач. Но корректность работы планировщика в целом - не зависит.

**2. Зависимость расшаренного формата**.

Есть два решения этой проблемы.

1. Сериализатор/десериализатор должен удовлетворять такому свойству, что сериализация значения, а затем его десериализация приводят к исходному значению. На эту тему обязательно изучите материал "Изоморфизмы и программирование " и приведённые там тесты. Так вот, из них видно, что наш изоморфизм явно зависит и от сериализации, и от десериализации - но мы говорим тут именно о зависимости изоморфизма как конкретного абстрактного свойства.

2. Мы можем также определить корректность для каждой стороны отдельно - в терминах абстрактного описания соответствующего формата хранения данных. Тогда корректность сериализации и десериализации будет зависеть от общего формата, но не друг от друга.

В обоих случаях сами сериализатор и десериализатор не зависят друг от друга, хотя они и связаны между собой. 

**3. Зависимость зависимости**.

Эту проблему решает суперспецификация (из второго материала по зависимостям) - пространство допустимых изменений, или, ближе к программисткой терминологии, замыкание. Если внутри B изменяется переменная, используемая в A, то A явно зависит от B, и программисту действительно нужно прочитать исходный код A, чтобы проверить, что в него не вмешивается (или вмешивается) логика B.

Но если наложить на B суперспецификацию, запрещающую модифицировать постороннее состояние (в качестве такой суперспецификации может быть например ваш тимлид, который отругал вас за то, что вы делаете в B такие модификации внешних состояний), то тогда зависимость (а вместе с ней и необходимость дополнительного изучения кода) исчезает.

**4. Зависимость краша**.

Этот вид зависимости, как вы, возможно, уже поняли - лишь продолжение предыдущей. На помощь снова приходят суперспецификации. Если мы рассматриваем в спецификации возможность разрушающих воздействий (из-за ошибок рантайма) в любом модуле, то, действительно, поведение каждого модуля зависит от всех остальных модулей. Но если сбойные воздействия в спецификации явно не учитываются, то и зависимости нету.

**5. Зависимость перебрасывания**.

Подобные сценарии изоморфны физическим примерам наподобие "если дождя не будет, включится поливайка". Тут два момента.

1. Зависимость не обязательно представляет собой одну конкретную точку, одно место в системе. Если CDN (или система кэширования) откажет, то изображение котике всё равно будет пользователю доставлено, поэтому загрузка изображения действительно не зависит от CDN. Но одновременное отключение и CDN, и резервного сервера - может! Таким образом, зависимость на самом деле зависит от множества {CDN, резервный сервер}, а сам CDN - только часть зависимости.

2. Но мы всё равно имеем полное право спросить: действительно ли будет одним и тем же использование B и переброс на C? Интуитивно понятно, что если вы загружаете изображение, то никак не зависите от кэша на сервере (за ислючением характеристики скорости доставки). С другой стороны, если платёжный сервис, принимающий международные карты, из-за технического сбоя перебрасывает вас на российский сервис, где такие платежи невозможны, то различие может обойтись дорого.

**6. Зависимость инверсии**.

Правильно думать об этом в контексте конкретных используемых инструментов. Например, если используется интерпретатор, то даже после инверсии зависимостей зависимость всё равно остаётся (т.е. поведение логики A во время выполнения остаётся зависимым от B, и мы об этом можем не подозревать). Но при использовании компилятора или тайп-чекинга с устранением всех предупреждений можно считать, что зависимость устранена (т.е. мы хорошо организовали систему типов, и наша вроде бы зависимость стала просто обычным корректным кодом, если мы сформировали её сознательно, с учётом всех последствий). 

**7. Зависимость зацикливания**.

Эта проблема также успешно решается с помощью стандартных причинно-следственных подходов из логики. К удивлению многих, причинность отнюдь не транзитивна - а значит, и зависимость тоже не будет транзитивной.

Обычно мы считаем зависимость транзитивной: A не может функционировать без B, а B не может функционировать без C, поэтому A не может функционировать без C. Однако, контринтуитивный момент, что нет, подобная зависимость не транзитивна. Условно говоря, я получил смс от X и хочу ему позвонить, но случайно нажимаю неверные кнопки, и телефон звонит у Y. Причина этого звонка телефона у Y - то, что я нажал некоторые кнопки, но никак нельзя назвать причиной этого звонка тот факт, что я получил смс от X или собирался позвонить к X.

Понимаю, что с этим можно поспорить :)

В целом, это технические моменты, зависит от того, как их описать формально. Конечно, многие виды зависимостей транзитивны - например, зависимости сборки проекта.

Для погружения в тему можно почитать ["Sufficient Conditions for Causality to be Transitive"](https://www.cs.cornell.edu/home/halpern/papers/transitivity.pdf) Joseph Halpern, Корнельский университет. 

**8. Зависимость высшего порядка**.

Опять-таки, эту проблему решает фактическая причина интересующего свойства. Корректность каждой функции определяется с помощью предварительного условия: если входные данные адекватны некоторым требованиям (пред-условие), то выходные данные считаются соответствующими желаемым. Если вы строите хэш-таблицу, а равенство ключей определяется подбрасыванием монетки, то причина плохого результата - вина не хэш-таблицы. Таким образом, корректность самой хэш-таблицы не зависит от конкретной реализации equals(), однако её поведение во время выполнения - зависит.

**9. Зависимость большинства**.

Это еще один классический паззл из литературы по причинности. Тут вновь становится актуальной "часть зависимости". Действительно, работа АЭС не зависит ни от одной из 5 программ, но она зависит от каждой "победившей коалиции" проголосовавших программ - то есть от каждого их подмножества размера 3. 
