Что такое состояние? В общем случае, это не просто число 1 в переменной типа Integer, и не просто некоторый набор значений полей объекта как его текущее "состояние". Это прежде всего описание того, как обстоят дела в данный момент.

Например:
Микроволновка включена.
Светофор не работает.
Цветовой стиль редактора переведён в тёмный режим.

Когда мы пишем программу, это универсальное состояние существует на четырёх уровнях:
- реальный мир;
- абстрактное состояние (модель сущности из реального мира);
- конкретное состояние (то самое "состояние" объекта например);
- интерпретация конкретного состояния (например, если в программе состояние объекта "Светофор N 256" равно "не работает", то делать то-то и то-то).
И когда мы говорим о пространстве состояний, то эти пространства будут сильно различаться в зависимости от того, о каком из этих уровней идет речь. Давайте разберемся, что они собой представляют.

1 - **Реальный мир** беспорядочен, нечёток, противоречив и полон столь большего количества нюансов, что мы даже можем себе представить их порядок. Например, вы пишете программное обеспечение для умной стиральной машины. Самое очевидное, что у нее есть одна или несколько ручек, передающих различные состояния.

Но у стиралки ещё есть цвет, воздух внутри, скорость отжима, трубы, винты - все они разной формы и размера, со своим состоянием и т. п. Список можно продолжать бесконечно.

2 - **Абстрактное состояние** - это отображение реальности в гораздо более простое подмножество сущностей, которое всё ещё полезно для моделирования интересующей нас системы. Причём выбор такого подмножества - это ответственность программистов.

Возможно, единственными интересными состояниями стиральной машины для наших целей будут такие:
- включена она или выключена?
- работает ли она?
- на какую "программу" стирки она настроена?

И мы сознательно отказываемся моделировать такое:
- потребление электроэнергии
- описательные состояния "Остановлено", "Готово", "Пустой", "Полный", "Ошибка". 

Что же такое абстракция?

**Абстрагирование, получение абстракции - это преобразование сложного множества в более простое, при котором операции и результаты в этой более простой абстрактной предметной области всё ещё говорят нам что-то важное об исходном множестве (сохраняют инвариант). На эту тему в СильныхИдеях есть немало других материалов**.

Пока на сегодня лучшее и достаточно формальное определение, которое я нашёл для учебных целей :) [такое](https://matt.might.net/articles/intro-static-analysis/).

Например, множество целых чисел ...,-2,-1,0,+1,+2,... отображаем в абстрактный домен {-,0,+}, где "-" - все отрицательные числа, "+" - все положительные.

Теперь можем сделать раскладку операций над этим доменом:

{+} + {+} = {+}
{+} + {-} = {+, 0, -}
{+} + {-} = {+, 0, -}

и т. п.

И теперь мы можем выполнять очень простой статический анализ без необходимости оценивать полное выражение, то есть нам не надо вычислять -4 \* +3, чтобы понять, что результат будет отрицательным.

На мой взгляд, это короткое, симпатичное и полезное отображение абстракции.

Точно так же, как мы можем создать абстрактное отображение между целыми числами и набором абстрактных символов, мы можем создать абстрактное отображение от реального мира к нашему абстрактному состоянию. Наше абстрактное состояние содержит только те детали, которые нам нужны. Однако операции и выразительность в этой более ограниченной области всё ещё говорят нам полезные вещи о реальном мире, причём, более того, мы можем получать нужные нам результаты просто и наглядно, отсекая множество ненужных вычислений "реального мира". 

3 - **Конкретное состояние**. Цель этого уровня - более близкое отображение 1:1 между абстрактным и конкретным состоянием, что разрешит в программе только те состояния, которые и должны в ней существовать, не более и не менее.

**Конкретное состояние - это тип данных**.

Например, мы определяем в программе тип Кот, для которого на подходящем уровне абстракции оказалось достаточно определить лишь три поля: два булевых Sleep и Running, и целое Hungry, принимающее значения от 0 до 10 (0 - полностью сыт, 10 - абсолютно голоден).

Однако, задав например в коде класс Cat с этими тремя полями, мы автоматически получим модель с огромным количеством плохих состояний (например, Sleep = true и Running = true). Это, собственно, самая ключевая проблема проектирования: мы хотим избавиться от таких состояний в идеале на уровне компилятора, не напихивая в код множество условных проверок. 

4 - **Интерпретация конкретного состояния** - это именно тот код из предыдущего абзаца, который корректно работает с конкретным состоянием (создаются конкретные объекты, их состояния обрабатываются условными инструкциями, и т. п.).

Вот у вас есть конкретное состояние - вышеописанный класс Cat, которое может потенциально представлять недопустимые состояния. Тогда решение, которое вы **всегда** должны применять первым - это сделать ваше конкретное состояние более строгим. Потому что, очевидно, если у вашего конкретного состояния нет возможности репрезентовать недопустимые состояния, то и код, использующий это конкретное состояние, также не сможет представлять эти состояния.

Но хотя это всегда самое предпочтительное решение, тем не менее есть веские причины не следовать ему:

- Скорее всего будет очень трудно передать детали абстрактного состояния конкретному состоянию. В примере с Cat подразумевается, что Sleep и Running не могут быть одновременно истинны, однако подавляющее большинство массовых языков программирования не способны выразить такую вещь разумным образом на уровне типа данных.

- Абсолютно корректное состояние обычно делает код гораздо более трудным для понимания, и выигрыш в корректности программы нивелируется усложнением работы с ней.

- Поддержка абсолютно корректного состояния может существенно ухудшить производительность программы.

Во всех этих сценариях причиной становится само неправильное состояние. Соответствующее решение должно быть подробно задокументировано и хорошо известно всем разработчикам, потому что код обязательно будет меняться, а компилятор здесь не спасёт.

Если же вы полагаете по каким-то причинам, что неправильное состояние в программе не может возникнуть (например, если убрать из Cat одно из полей Sleep или Running, два оставшихся будут конфликтовать уже слабее, хотя всё равно вряд ли котику нормально спать сильно голодным, или носиться сильно сытым) - убедитесь, что ваше конкретное состояние точно соответствует вашему абстрактному состоянию. Но подобные моменты уже затрагивают гораздо более глубокие уровни размышлений, в частности, думание на трёх логических уровнях вашей программы (изучите соответствующие материалы в СильныхИдеях).

Итак, в чём же цель проектирования как моделирования данных?

**Сделать отображение между абстрактным и конкретным состояниями, а также между конкретным состоянием и его интерпретацией, как можно ближе к "один к одному"**. 

## Четыре пути, которыми ваши состояния могут стать ошибочными

Как обнаруживать и как исправлять неправильные состояния? Рассмотрим только одно отображение - между абстрактным состоянием и конкретным состоянием, потому что любые проблемы, которых удалось избежать (или не удалось избежать) на этом самом первом шаге, будут распространяться дальше. Как обычно, ошибки проектирования обходятся на порядки дороже ошибок в непосредственной реализации.

Есть четыре способа, которыми конкретное состояние может стать некорректным - то есть, не подпадающим под требование соответствия 1:1 с абстрактным состоянием.

1 - **"Пропавшие" состояния**: когда существуют абстрактные состояния, которые не выражает никакое конкретное состояние.

Как их выявить?
В ТЗ имеются некоторые достаточно простые требования, которые не соблюдаются полностью (или не везде), потому что конкретное состояние недостаточно выразительно, чтобы включить некоторые отдельные случаи.

Самый распространённый пример - отсутствие состояния Error, когда оно должно быть согласно ТЗ.

Как пофиксить?
Добавить уникальное конкретное состояние.

Например, функция должна обрабатывать типизированный список, но если он пустой, она "ломается". Идеальное решение (но далеко не всегда доступное, в основном пока лишь в функциональных языках, в виде алгебраическвих типов данных например) - создать два вида (типа) такого списка: "пустой" и "непустой", и подавать функции на вход только списки типа "непустой", в таком случае многие потенциальные ошибки выявит компилятор.

В обычных языках со статической типизацией (Java, C++, ...) это в принципе можно тоже решить аналогично созданием двух классов-наследников основного класса-списка (гарантированно пустой и гарантированно непустой список). Напомню материал "Быстрая прокачка в ООП", где предлагается любые стандартные коллекции оформлять отдельными типами данных в программе. 

2 - **Незаконные состояния** - это конкретные состояния, которые не имеют отображения на абстрактное состояние.

В первом случае у нас были неотображённые абстрактные состояния, а тут ситуация обратная: в программе появились неотображённые конкретные состояния, которым не соответствуют никакие понятия предметной области. Тут возможны некоторые исключения, которые разбираем на третьем курсе по ООАП: конкретные состояния, связанные отображением с абстрактными состояниями, по Бертрану Мейеру называются состояния (классы) анализа, и возможны также состояния (классы) проектирования, ответственные за внутреннюю архитектуру системы, и состояния (классы) реализации, ответственные например за реализацию различных алгоритмов и структур данных. В данном пункте мы говорим только о состояниях анализа.

Важная цель этапов анализа и проектирования - сделать незаконные состояния непредставимыми в программе. Однако не очень искушённые в проектировании разработчики могут плодить в программе немало состояний (классов), которые сами по себе вроде бы и нельзя назвать незаконными, однако они интуитивно обычно смотрятся как минимум избыточными. Где тут грань?

На упомянутом курсе по ООАП предлагается к допустимым состояниям (классам анализа) относить только "реализации" абстрактных типов данных, которые (АТД) сами по себе по определению моделируют с помощью набора своих операций концепции, явно выделенные в техническом задании например, или в ходе общения с заказчиком, и т. д.

Но как разделять незаконные и избыточные состояния?

Инженерный приём такой: допустим, в программе имеется сущность X, которая должна быть активирована, чтобы было выполнено действие Y. Например, кот может выполнять действие "кушать", только если активирована фича "кот не бегает".

Если кот может выполнить "кушать", когда активна фича "кот бегает", и в результате в программе возникает неопределённое поведение (например, возникло исключение вследствие нарушения инварианта класса Кот), значит, программа содержит незаконные состояния. Если же фича "кот бегает/не бегает" просто игнорируется, кот всё равно может кушать, даже если он бегает, и неопределённого поведения при этом не возникает, значит в программе есть избыточные состояния.

Как пофиксить?
Очевидно, удалить незаконные конкретные состояния. Сделайте их непредставимыми в программе.

Тут есть три варианта. Во-первых, в ТЗ может не быть абстрактного состояния "кот бегает", поэтому его надо аккуратно удалить из системы (это и есть данный пункт). Во-вторых, это может быть избыточное состояние, которое тоже желательно удалить (см. далее). В-третьих, может оказаться, что отображение между соответствующими конкретным и абстрактным состоянием всё же требуется (постановщик или заказчик это уточнили) - тогда переходим к следующим пунктам.

Вот [пример](https://github.com/bitcoin/bitcoin/blob/2f71a1ea35667b3873197201531e7ae198ec5bf4/src/coins.h#L112-L126) незаконных состояний в кодовой базе биткоина :)

На этом логическом уровне их удается избежать благодаря очень тщательному кодированию при интерпретации соответствующего state. Подумайте, как сделать это конкретное состояние более строгим, чтобы потенциальные ошибки стали невозможными уже на уровне проектирования? 

3 - **Избыточные состояния**.

В программе появляются избыточные состояния, когда существует более одного способа представления некоторого абстрактного состояния.

В двух предыдущих случаях в программе появлялись состояния, никак не связанные с другими. Этот и следующий случай - когда, наоборот, связи имеются, но не соблюдается принцип соответствия один-к-одному между абстрактными и конкретными состояниями.

Как уже говорилось, избыточные состояния имеют сильную связь с незаконными состояниями. Легко перейти от наличия избыточных состояний к наличию незаконных состояний - достаточно лишь неправильно интерпретировать одно из дополнительных избыточных состояний.

Самый лёгкий (в плохом смысле) способ получить избыточное состояние - влепить новое поле в объект. Как в случае с котом, пока в классе Cat есть только два поля Running и Hungry, слишком уж явных конфликтов не возникает: как известно, даже плотно покушавшие котики обожают носиться по комнате. Однако стоит добавить в него третье поле Sleep, как логика поведения может поломаться, при том, что во многих случаях существующий код будет нормально функционировать как и раньше. Теперь в программе возможны абсурдные ситуации, когда кот одновременно и спит, и бегает, однако недопустимого поведения не возникает.

Как определить? Уже говорилось в предыдущем пункте: если в программе есть опции, которые применяются только в определённых сценариях, но их всегда/произвольно можно выбрать (например, в класс Cat тупо добавлены сеттеры для Running и Sleep), это означает, что какие-то сущности в системе находятся либо в незаконном, либо в избыточном состоянии. Избыточные состояния появляются, если изменение этих специфических фич не даёт никакого эффекта. Мы можем произвольно менять поля котика Sleep и Running, и все четыре возможные комбинации никак не влияют на поведение программы.

Как пофиксить? Удалить конкретные состояния (сами классы или их атрибуты).

Например, запретить произвольное изменение любого из полей Sleep и Running без учёта состояния другого поля. Тут вполне может возникнуть проблема с необходимостью плодить множество условных проверок, и на уровне классического ООП обойти её трудно. Можно определять классы-наследники под соответствующие состояния, но тогда иерархия классов будет невероятно разрастаться.

Наилучший способ тут - отказываться от думания на уровне полей/состояний, и переходить к думанию на уровне АТД: есть только операции над объектом, корректно меняющие его состояние, и такая корректность задаётся с помощью пред- и пост-условий. 

4 - **Перегруженные состояния**.

Состояние считается перегруженным, если в проекте есть одно конкретное состояние, представляющее два разных абстрактных состояния.

Это, вероятно, наиболее общая и частая ошибка.

Как определить? В паблике вк приводил пример, который встречал, наверное, каждый пользователь интернета: сперва вам показывается сообщение "нет сообщений / нет лайков / на вашем счету 0 рублей", и через секунду появляются уже ненулевые значения. Это и есть эффект перегрузки.

В "Быстрой прокачке в ООП", напомню, рекомендовалось обёртывать любые коллекции в прикладные типы данных в проекте, причём в таком типе/классе должен быть только один атрибут - эта коллекция. А вот доступ к ней возможен только через ограниченный набор методов - сильно меньший, нежели стандартный набор методов этой коллекции. Но в более-менее сложной системе такой тип-коллекция вполне может запрашивать/подкачивать данные себе по внешним API, которые достаточно медленны. Тут и возникает невозможность разделить два абстрактных состояния:
- список пуст, потому что от API только что пришёл ответ с нулём элементов;
- список пуст, потому что API давно не опрашивался по поводу наличия элементов.

Поэтому нам нужна дополнительная контекстная информация, чтобы понимать, как интерпретировать текущее состояние. Из того, как устроена подобная коллекция, невозможно вывести такое различие. И это кстати очень частый антипаттерн на фронтенде, известный баг в твиттере, а как правильно об этом думать, очень хорошо описано [тут](http://blog.jenkster.com/2016/06/how-elm-slays-a-ui-antipattern.html).

Как пофиксить? Добавить соответствующие конкретные состояния.

Если мы начнём с вопроса, какие состояния вообще должны наличествовать для данных, получаемых от API, то при определённом уровне понимания уясним, что такие четыре состояния будут наилучшим абстрактным описанием происходящего:
- не запрашивались;
- загружаются;
- список получен успешно;
- неудача, код ошибки.
Это вполне может быть и второе поле в классе коллекции.

В зависимости от наших требований к абстрактному состоянию, мы можем продолжить детализацию возможных состояний, или довольствоваться очередным текущим уровнем.

Например, как бы вы изменили модель коллекции, чтобы обеспечить дополнительную возможность постраничного просмотра элементов, сохранив при этом текущие данные? 

---

В заключение, универсальный рецепт применения данных рекомендаций:

1. Пересматриваете проект, какой из двух видов неверных состояний встречается: избыточные состояния или перегруженные состояния.

2. Если найдено избыточное состояние, ликвидируете его, после чего скорее всего у вас в программе появится незаконное состояние: вы разорвали связь один-ко-многим абстрактное - конкретные состояния, однако лишнее конкретное состояние осталось теперь как избыточное. Проверяете получившийся код на этот момент.

3. Если в п.1 было найдено перегруженное состояние, ликвидируете его, после чего скорее всего у вас в программе появится "пропавшее" состояние: вы разорвали связь один-ко-многим конкретное - абстрактные состояния, однако появилось лишнее абстрактное состояние, которому не соответствует никакое конкретное. Проверяете получившийся код на этот момент.

4. Возвращаетесь к п.1 и выполняете этот цикл до тех пор, пока в п.1 находятся избыточные или перегруженные состояния.

5. Просматриваете проект в поисках пропавшего или незаконного состояний, и аккуратно их ликвидируете.

Готово: ваша программа идеально спроектирована! Каждому абстрактному состоянию соответствует ровно одно конкретное состояние. 
