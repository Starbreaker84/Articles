## Пишем правильный полиморфный код

Фактически все современные руководства по стилю (включая и мой курс Ясный код) принуждают нас писать т.н. **мономорфный** код, хотя мы сами при этом обычно ошибочно думаем, что он полиморфный (когда любую сигнатуру функции/метода/типа мы можем реализовать множеством способов). В рядовых прикладных проектах такой подход, безусловно, полезен: тимлид знает, что Олег или Зухра напишут сильно разные реализации, которые однако работают примерно одинаково за O(N*N), и это все стороны вполне устроит.

Но тут возникает такой контринтуитивный момент, противоречащий всем гайдам по стилю, который тем не менее есть прямое логическое следствие прикладной полезности полиморфизма кода: когда вы делаете длинные наглядные имена переменных/функций/... , это плохо!

Буквально, во многия знания много печали )))

Какое это имеет отношение к полиморфизму? Вот ровно потому, что если мы хотим поддерживать полиморфизм концептуально везде в проекте - и на уровне семантики, и на уровне синтаксиса - тогда нам придётся признать, что имя переменной "BanTheUserForever" - мономорфное, а вот "a", или "i", или "n" - полиморфное, т.к. допускает вложение в него множества смыслов. Только помним, что множество смыслов и множество реализаций - противоположные понятия. **Чем больше смыслов охватывает наш более полиморфный универсальный код, тем меньше вариантов его реализации нам будет доступно.**

**И чем больше у вас конкретной, специфической информации о функциях, типах и т.п., тем большее количество операций вы можете с ними выполнять. Появляется множество способов всё испортить.** Разработчики в таких ситуациях стремятся "естественно" уточнять типы, сигнатуры и т. п., но вот именно такой путь дальнейшего увеличения количества информации и ведёт в мономорфный тупик.

Казалось бы, чем более точными мы делаем типы, тем меньше манипуляций с ними мы можем выполнять? Нет, это неочевидный, но весьма важный момент: **типы надо делать не более точными, а наоборот более общими - именно это и ограничит ваши возможности!**

Далеко не все операции в коде можно легко обобщить, но в этом подходе есть глубокий урок. Большинство программистов умеют скрывать реализацию (функций, классов, ...) от внешнего мира, для чего практически во всех языках программирования имеется хорошая поддержка (видимость методов, интерфейсы, API...). Логики сразу увидят в этом квантор существования: внешний мир видит доступный интерфейс, но не знает внутренних деталей. Но лишь 2% логиков при этом вспомнят и про его двойника - универсальный квантификатор, который скрывает от модуля внешний мир.

В функциональном программировании этот момент представлен чистыми функциями, которые никак не связаны с внешним миром, и поэтому всегда, получив на вход конкретное значение, будут выдавать один и тот же результат. И когда вы пишете такие функции, оказывается, что часто удаётся реализовывать логику, не уточняя её до конкретной узкой задачи, а наоборот, обобщая до более универсального случая.

Таким образом, мы получаем более полиморфную функцию, и при этом существует уже меньшее количество способов её реализации. В идеале мы добираемся до такого уровня полиморфизма, когда можем делать имена всех наших переменных и параметров полностью абстрактными, и связанными исключительно с именами их типов. При этом мы можем избавиться от кучи кода, который был завязан на специфику обработки исходных конкретных типов со своими низкоуровневыми особенностями.

И даже если такая функция по своей логике получилась довольно сложной, ничего страшного: ведь мы за её счёт избавились от кучи мономорфного кода.

Данный подход, конечно, не уникален только для функционального программирования. В ООП хорошо известен принцип **"берите для реализации метода наименее мощный интерфейс"**.

Другими словами, если ваш метод должен сообщать, является ли объект фигурой, то не нужно от него требовать, чтобы он проверял, является ли объект шестиугольником (подтип фигуры).

Эта техника применима и к функциональному программированию, но поскольку тут обычно нету подтипов, мы используем полиморфизм, а когда его недостаточно, мы добавляем ограничения в виде тайпклассов.

Будь то ООП или ФП, эффект один и тот же: **повышение полиморфности кода уменьшает пространство возможных реализаций**.

Мономорфные сигнатуры типов/функций очень конкретны. Они позволяют формулировать длинные, наглядные, описательные имена переменных, поскольку вы точно знаете, с какими типами вы работаете, и что они семантически представляют в вашем проекте.

Тёмная сторона мономорфных сигнатур типов заключается в том, что им соответствует гораздо больше сущностей. Существует так много способов их реализации, что ваши шансы испортить её сравнительно высоки, и при этом существенно труднее рассуждать о её корректности.

Введение полиморфизма может существенно ограничить пространство возможных реализаций и упростить (как минимум) мысленную проверку корректности куска кода. Полностью полиморфные сигнатуры типов уже фактически не допускают описательных имён переменных, но значительно ограничивают пространство реализаций.

Иногда мы можем развить полиморфизм в коде весьма "высоко", а иногда нет. Но даже когда нам явно нужен мономорфизм, мы можем запихать как можно больше функциональности в весьма маленькие кодовые кусочки полиморфизма.

Эта техника, которую придумал John De Goes (автор легендарной конференции Lambda-Conf), допускает применение практически везде, существенно уменьшая общее количество функциональности, реализованной мономорфно.

Конечно, как и со всеми техниками рефакторинга, можно переусердствовать и с применением этой техники. **Но в целом, рекомендация опытным разработчикам всегда искать больше способов "полиморфизации" кода (а не меньше).**

Простейший пример. Вы делаете список дел ToDo, определив его в виде класса, который содержит приватное поле - список-хранилище "тудушек" ToDoItem, и методы Done и SetPriority для todo-элемента с заданным id из списка. 98% программистов оформят класс именно так: внешний мир никак не может добраться до списка элементов и как-то его испортить. Этому учат абсолютно на всех курсах и во всех университетах, ну может быть кроме МИТ и Гарварда :)

Однако, очевидно, где-то в других местах приложению в любом случае нужно будет редактировать отдельные "тудушки". И, вероятно, такое редактирование не должно иметь никаких дел с конкретными списками элементов todo.

Промежуточный компромиссный, быстрый, "по форме", вариант решения этой проблемы (курс "Быстрая прокачка в ООП") заключается в том, что мы оформляем список не как стандартный список/массив объектов заданного типа, а как отдельный пользовательский тип (класс) TodoList, в котором допустим строго ограниченный набор операций. Таким образом мы немного уходим от мономорфизма, хотя и не сильно, но как минимум отвязываемся от конкретной сигнатуры списка, в котором явно прописан и стандартный тип списка, и тип ToDoItem.

Стратегически важен более глубокий "полиморфный" принцип: **большая часть кода нашего класса должна быть написана таким образом, чтобы не делать никаких предположений ни о способе хранения "тудушек" (предыдущий абзац об этом), ни даже о самих элементах TodoItem - и продолжать успешно работать в будущих реализациях.**

Это нетривиальный момент: мы не говорим, что TodoItem должен быть обязательно скрыт от остальной части приложения. TodoItem вполне может находиться "внутри" дополнительного пользовательского класса TodoList, описывающего список "тудушек". Но! Речь скорее о том, что **классу TodoItem по отношению к TodoList всё равно желательно оставаться внешним**: наиболее правильно, что TodoItem должен быть скрыт от самого TodoList (через дженерики, например). 
