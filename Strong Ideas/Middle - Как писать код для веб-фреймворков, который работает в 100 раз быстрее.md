**ORM (объектно-реляционная раскладка)** -- это такая кривейшая приляпка, реализованная однако практически в каждом популярном веб-фреймворке. Кривейшая -- потому что объектные и реляционные системы типов несовместимы в принципе, однако "для удобства" массы ленивых разработчиков и была придумана ORM, эффективно реализовать которую невозможно в принципе.

Программисты приучены к императивному кодированию, приучены к стилю обработки списков, а ORM вдобавок добавляет буквально десятки (не преувеличение) промежуточных слоёв, которые проходят обращения к объектам с самого верхнего уровня до нативного SQL. Поэтому на практике, когда например требуется отобрать пользователей из общего списка пользователей, для которых выполняется некоторое условие по совпадению, например, с ролями из другого общего списка ролей, программист пишет два цикла: первый по коллекции пользователей, и второй вложенный по коллекции ролей, и внутри проверяет условием совпадение, добавляя подходящего пользователя в отдельный список. А если ещё этих пользователей требуется для удобства дальнейшей обработки отсортировать, например, по id роли? Даже без обращения к ORM такой тяжёлый код будет работать медленно -- за O(N*M) + какая-то ощутимая нагрузка для внутренней сортировки с помощью словаря (в идеале). А уж в какой-нибудь Hibernate только для получения списка пользователей потребуется отдельное обращение к базе данных, и куча потраченных впустую циклов процессора, и ненужная нагрузка на сеть для передачи лишних результатов.

В computer science есть такое направление **Query By Synthesis** (QBS), которое в последнее время стало развиваться особенно активно с появлением хороших систем машинного обучения: например, генерация SQL-запросов из запросов на естественном языке. Однако исходно QBS занимались более прикладными в плане программирования вещами: брали исходный код вроде вышеописанного, который выполняет итерации над коллекциями, отображёнными на базу данных, и превращает их в SQL-запросы, которые делают то же самое, но значительно (в десятки раз!) эффективнее. В нашем случае достаточно будет одного линейного SQL-запроса к двум таблицам с простым WHERE и ORDER BY. В QBS-системах это работает так: исходный код транслируется в некоторые логические формулы, описывающие состояние программы на каждом шаге, после чего они преобразуются в SQL-запрос, оптимизацией которого может заняться сама СУБД.

Но подобный автоматизированный рефакторинг к сожалению массово не распространён, хотя польза его очевидна, поэтому сформулируем пару поучительных уроков.

1. Когда вы пишете нагрузочный код, подразумевающий обращение к ORM, обязательно учитывайте внутреннюю механику, внутреннее устройство ORM. В данном случае можно было попытаться объединить два цикла в один, чтобы использовать не два раздельных списка, а список пар. В .NET/C# есть отличный язык запросов к данным LINQ, непосредственно интегрированный в код. В Java есть Stream API, и т. п. В Django есть возможность записывать в коде прямые SQL-запросы (для чего, конечно, надо хорошо понимать, в какие таблицы отражаются модели), и такой подход может привести к чудесному сокращению вашего кода. Подобные маленькие шаги на самом деле могут дать большие скачки производительности, но они также могут и загнать вас в тупик.

2. QBS работает совершенно по-другому: он полностью выбрасывает существующий код и создаёт нечто совершенно новое на основе исходной семантики. По этой причине, приступая к подобному ручному рефакторингу, начните с того, что **сделайте шаг назад от текущего кода**, не смотрите на его форму, и спросите себя: "**что на самом деле пытается сделать этот код?**". QBS действительно тоже "преобразовывает" код мелкими шагами, однако это преобразования между кодом и логикой (по содержанию), а не между **кодом и кодом** (по форме).

3. И есть ещё одно, более коварное следствие. Как правило, ORM при запросе, например, всех пользователей и всех ролей, выдаёт их по умолчанию упорядоченными по их id (что довольно естественно и удобно), поэтому и результирующий список (скорее всего) получается упорядоченным по id пользователей, а внутри каждого пользователя -- по id ролей. Но можно ли считать это запланированным поведением, или же это просто совпадение? QBS этого не знает, однако при логических манипуляциях будет считаться, что значения упорядочены, поэтому QBS должна быть консервативной и сохранить порядок (говоря о QBS, я подразумеваю прежде всего вашу схему мышления над подобными задачками). Поэтому, тем не менее, QBS не может определить, требуется ли ORDER BY, просто изучив исходный код. Теперь предположим, что список пользователей с их ролями будет отображаться в браузере. Будет ли ошибкой, если они при каждой перегрузке веб-странички вдруг начнут появляться в другом порядке, или это просто другое, но приемлемое поведение?

Эта проблема гораздо обширнее -- рекомендую поразмышлять над ней отдельно. Потому что вот именно так код и запутывается в разных частях кода проекта, несмотря на кажущееся отсутствие связи между ними. В одном месте вы закладываетесь на упорядоченность данных, а в другом - нет. Вот почему **вам необходимо чётко определить, на какие "поведения" вашего кода можно полагаться, а какие случайны**. Это делается с помощью документации, и через описания классов как АТД с пред- и пост-условиями. Например, если бы вы хотели в этом примере явно показать, что возвращаемый порядок элементов не имеет значения, то вы могли бы возвращать пользователей как множество.

Хорошая модульность вырастает из разрыва между поведением реализации и гарантиями спецификации. **Будьте конкретны в своей реализации** (например, задавая Set как явный тип результата), **но расплывчаты в спецификации** (ослабьте требования к упорядоченности, а лучше удалите их, если они явно не требуются). 
