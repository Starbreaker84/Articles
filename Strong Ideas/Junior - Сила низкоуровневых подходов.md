Я постоянно призываю думать над проектом как можно более сильными абстракциями, и может показаться, что для этого надо использовать только небольшое число функциональных языков со строгой системой типов. Но нет, мне на самом деле очень нравится язык Си. Я очень много на нём программировал, и по большому счёту, есть настоящая магия в том, когда "список байтов" становится фундаментальным типом данных. При использовании языков более высокого уровня в ряде ситуаций трудно понять, что на самом деле происходит во время выполнения (а это важно), но **Си идеологически близок к ассемблеру, а ассемблер никогда не врёт**. Ассемблер - это истина в конечной инстанции.

Сейчас модно говорить, что дескать Си - это совсем устаревший язык из прошлого, который всё ещё используется только потому, что пока разработчики недостаточно изучили Rust или Go. Но есть ли какие-то реальные преимущества у Си, кроме высокой производительности и приближённости к машинному коду?

Хорошая статья кембриджского учёного на эту тему: ["Some Were Meant for C"](https://www.humprog.org/~stephen//research/papers/kell17some-preprint.pdf).

Вот её краткий смысл: Язык Си ведёт двойную жизнь - как язык прикладного программирования прошлых лет, увековеченный обстоятельствами, и как язык системного программирования, который остаётся хорошим выбором и спустя десятилетия после его создания.

Это эссе ставит под сомнение такие распространённые негативные убеждения относительно Си, как небезопасность, неопределённое поведение и чрезмерный акцент на производительности. Не то чтобы этих недостатков у Си не было; речь скорее о том, все эти свойства на самом деле несущественны; главная суперспособность языка Си заключается в его **коммуникативном дизайне (communicative design)**, который действительно нелегко вписывается в классические рамки массового представления о "языка программирования", и может рассматриваться как противопоставление так называемым "управляемым языкам". Но именно эта коммуникативность облегчает важнейший аспект разработки сложных систем: **создание частей, которые взаимодействуют друг с другом "удалённо" - "рядом", а не "внутри" (слабая связанность модулей)**.

Что именно Stephen Kell подразумевает под коммуникативностью? Речь о том, что **Си может получить доступ к структурам данных, которые были созданы другими системами, фактически без лишних усилий**. Хотите ли вы получить доступ к структурам данных ядра Linux или возиться с байтами, представляющими исполнимый код других программ, Си сделает это легко. Представьте, что вы разбираете сетевой пакет, содержащий некоторые структуры данных в соответствии со стандартом. Си может просто сказать: "Я знаю, что это такое", наложить на пакет просто как на последовательность байтов свою собственную структуру, и прочитать его как есть. В языках же вроде Java придется отдельно "вручную" десериализовать пакет в свою собственную структуру данных.

Некоторые разработчики говорили, что этот материал ["Some Were Meant for C"](https://www.humprog.org/~stephen//research/papers/kell17some-preprint.pdf) изменил их вычислительное мировоззрение :) Может быть, это случится и с вами?

Здесь есть и более общий урок: **сила расшаренного формата**. Не только возможность читать и писать данные в одном и том же формате, но и прозрачное его использование во внутренних вычислениях. 40 лет философия Unix демонстрирует, какую мощь вы можете получить, если у вас будут пайпы программ, которые общаются с помощью обычного текста. Это невероятно контрастирует с конкурирующей философией проприетарных форматов файлов вообще для всего, так что всё взаимодействие с ними должно проходить через промежуточные конвертеры.

Таким образом, урок языка Си - это великолепный урок, который мы можем повторить и в повседневной практике и жизни: **чтобы общаться с другими, мы должны научиться говорить на общем языке, а не постоянно переводить тексты туда-сюда**.

И всегда, когда вы думаете, что какая-то технология добилась успеха наперекор своей, как нам кажется, технической неполноценности, подумайте ещё раз. 
