Одна из частых причин запутывания системы - это её раздутость.

**Раздутость** - это когда в системе копится множество конкурирующих "фич", и вы не можете работать над одной конкретной функциональностью, если не будете при этом дополнительно заботиться о куче других "фич", казалось бы, никак с ней не связанных.

За раздутость нередко принимают просто объёмный и грязноватый код, когда вы используете сотни и тысячи вариантов схожего кода для всех мыслимых целей. Такой код определённо большой, но не обязательно раздутый. Возможно, вам надо просто аккуратно проработать тему повторного использования разумного количества функций для "основных" частей системы.

**Действительно коварный вид раздутости возникает прежде всего из-за сложных условий, размазанных по всему вашему коду**. Например, некоторое поле таблицы или класса в зависимости от контекста обращения к нему может хранить как информацию о технических правах пользователя в системе, так и информацию о его финансовых правах. Такая странная форма, однако, далеко не редкость. Например, в классическом Windows API (очень раздутом) есть множество функций, логика работы которых напрямую зависит от значений их параметров (если второй параметр равен NULL, то первый параметр хранит дескриптор файла, а если нет, то третий параметр содержит текстовое имя файла). Это - **инвариант, который всегда создаёт дополнительную нагрузку на код: его надо соблюдать на память во множестве мест в коде**. Раньше достаточно было просто взглянуть на структуру данных, чтобы понять, как с ней работать, но теперь возникает сложный процесс выяснения того, в какой цепочке вызова функции вы находитесь, в каком контексте она вызывается. Это усложнение простых вещей. Это и есть раздувание.

Очень важное следствие такое, что подчас **самые обычные, "неименованные" кусочки вашего кода - меньшие, чем функция - сами по себе вполне могут быть семантически значимыми**. Более того, как раз они часто и становятся лучшими строительными блоками.

Например, вы написали цикл сканирования массива, в теле которого выполняете сразу две вещи: ищите максимальное значение в массиве, и одновременно суммируете его значения. Такое вполне допустимо, когда, например, подразумевается, что размер массива огромен, и даже два прохода по нему делать неэффективно. Или даже это может быть не массив, а поток входных значений (по сети), повторить итерацию по которым невозможно. Но при этом даже такой простой код выглядит уже немного запутанно, так как в цикле реализовываются две совершенно разные и никак не связанные задачи.

В языках функционального программирования имеются довольно мощные механизмы для экспортирования подобных вычислений по частям, которые можно описывать раздельно, а затем синтаксически наглядно объединять. Например, это библиотека [foldl](https://hackage.haskell.org/package/foldl) для Haskell ("Composable, streaming, and efficient left folds").

В вашей рабочей практике, скорее всего, нету подобных инструментов, однако всё равно тренируйтесь видеть в коде автономные потоки вычислений - распознавайте их отдельно, даже когда они намешаны в код-лапшу, которая для обычного программиста действительно просто лапша. Для начала пишите соответствующие грамотные комментарии в коде, которые разделяют такую синтаксически смешанную логику.

Как распознавать такие потоки?
Линус Торвальдс однажды сказал: "Плохие программисты думают о коде. Хорошие программисты думают о структурах данных и взаимосвязях между ними".

**Начните думать не кодом, а структурами данных и взаимосвязями между ними**. Потоками данных в системе, преобразованиями данных, где функции - просто промежуточные трансформации... 
