Ключевой вопрос любой зависимости независимо от её типа, очевидно, такой: **"Зависит ли А от B?"**.

Для наглядности возьмём технический пример. Сегодня очень многие приложения используют аналитические фреймворки для сбора статистики по посетителям - например, яндекс-метрику. Классический подход - добавить некоторый промежуточный уровень абстракции (обёртку) , чтобы не привязываться явно к конкретному фреймворку. Внутри приложения такая абстракция предоставляет собственный API, чтобы конкретный фреймворк можно было в случае чего свободно менять.

Внимание, вопрос: зависит ли такая система от яндекс-метрики?

1. Нет. Наша система и метрика - это два совершенно разных продукта, разрабатываемых и разворачиваемых совершенно разными компаниями.
2. Да. В любой момент, когда яндекс-метрика падает, падает (или как минимум начинает неполноценно работать) и наша система.
3. Нет. Мы легко можем сменить метрику на любой другой фреймворк без изменения в коде системы.
4. Да. Фреймворки могут сильно различаться по качеству, и перейдя например на google analytics, мы можем получить сильно лучшее (или сильно худшее) качество некоторых аспектов работы и нашей системы.
5. Да. Любая уязвимость безопасности во фреймворке будет и уязвимостью нашей системы.

Сермяга в том, что все эти ответы определённо отвечают на самые разные вопросы, а не на один вышеупомянутый.

Как правильно разбираться с зависимостями?

Любая зависимость характеризуется как минимум тремя параметрами:
1) **семантика или конкретная вычислительная модель**,
2) **ключевые свойства**,
3) **пространство допустимых изменений**. 

**1. Семантика**

*"мой проект включает PostgreSQL в качестве зависимости, но он не зависит от него, если эта база данных не используется, и фактически он и не зависит от него, потому что мой проект не зависит от базы данных"*.

Сменив базу данных на аналитический сервис, мы получим вышеприведённый пример с яндекс-метрикой. В этом высказывании слово "зависеть" используется тремя разными способами. И дело не столько в том, что каждый способ использования "зависеть" - это ответ на разные вопросы. На самом деле это **разные вычислительные исполнительные модели**.

Например, момент, когда вы импортируете новый пакет в ваш проект, создаёт в нём "зависимость". Однако проект не будет "зависеть" от этого пакета до того момента, когда не начнёт его непосредственно использовать. Причём в случае, когда в проекте использовалась гугл-аналитика, и затем вы меняете её на яндекс-метрику, не меняя сам код (возможно, лишь настраивая конфигурационные файлы), то вполне можно сказать, что код не "зависит" от гугл-аналитики. Однако все эти три случая "зависимостей" качественно разные.

**1.1. Зависимости сборки**.

Когда речь идет об "импорте" зависимости (физическом импорте пакета), исполнительной моделью становится компилятор или система сборки: хорошо ли скомпилирована программа, не возникло ли ошибок сборки? Это примерно соответствует более теоретическим терминам "статической семантики" или "системы типов".

**1.2. Зависимости времени выполнения**.

Когда мы добрались до фактического обращения к пакету - это исполнительная модель уровня интерпретатора, или комбинация компилятор + процессор. Тут основное внимание уделяется тому, действительно ли импортированный код выполняется, и вносит ли он вклад в общий результат работы программы. "Динамическая семантика" - это подходящий теоретический термин для того, что на самом деле происходит при подобном выполнении. 

**1.3. Функциональные требования**.

Когда мы утверждаем, что программа продолжит работать "так же как и раньше" даже после перехода на другую библиотеку, исполнительная модель уже фактически только ментальное рассуждение разработчика, с помощью которого он пытается убедить себя (или кого-то другого) в том, что программа верна / достигает своей цели, основываясь только на гарантированных свойствах уровня абстракции API аналитики. Если вы согласны с тем, что человеческие рассуждения аналогичны автоматическим (в целом это, конечно, не так), то теоретический термин, который это отражает - пресловутая " программная логика", система доказательств, используемая для того, чтобы показать, что программа достигает своих целей. Сегодня уже существуют формальные системы обеспечения подобных доказательств корректности/соответствия кода и модели (пруф-ассистанты например), однако они пока весьма сложны и дороги в эксплуатации.

Теперь мы уже можем понемногу классифицировать ответы по аналитическому фреймворку. Невозможность раздельной сборки (например, с новым внешним аналитическвим пакетом) относится к статической семантике (ответ на первый вопрос). Когда сбой в одном месте программы во время её работы вызывает сбой в другом месте, это динамическая семантика (ответ на второй вопрос). Возможность сменить один фреймворк на другой, и всё равно получить "примерно так же работающую" аналитику - это логика программы (ответы на три последних вопроса).

Два последних ответа (о точности и безопасности) также следует отнести к логической корректности. Но в целом одной семантики недостаточно, т.к. пока слишком много моментов ещё смешиваются. 

**2. Характеристики**.

В двух последних (из пяти) ответах мы отмечали, безопасен ли фреймворк, и насколько в нём качественная аналитика - на самом деле это два разных свойства.

Вы никогда не должны спрашивать, зависит ли модуль A от модуля B. Лучше спросите, **зависит ли некоторое свойство P модуля A от модуля B?**

Таким образом мы можем например сказать, что у нас есть зависимости определённых характеристик нашей системы от поведения используемого фреймворка во время выполнения, от его собственной производительности и от его безопасности, и нету зависимости от конкретного аналитического фреймворка (с определёнными допущениями по поводу фазы сборки) и от его качества в целом (в том смысле, что его можно при необходимости достаточно быстро сменить на другой без модификации кода).

Хотя разные нюансы ещё остаются. Например, в плане безопасности одни версии фреймворка могут работать надёжно, а другие легко взламываются (или просто работают нестабильно). Так что, возможно, зависимость от качества в целом всё же есть? 

---

Вернёмся к предыдущему списку из 9 видов зависимостей. Зависит ли планировщик round-robin от отдельных задач? Очевидно, что да - по многим характеристикам времени выполнения. Но относительно корректности планировщика в целом это не должно быть так.

...если только это не вытесняющий планировщик и некоторая задача зависла и не формирует аппаратные прерывания, и отнимает всё время планировщика. Так что да, возможно.

То есть нередки ситуации, когда вроде бы не видно никакой зависимости от компонента - за исключением того, что этот компонент может "выйти из коробки" и испортить всю остальную систему. Вот тут-то и появляется третье измерение. 

**3. Допустимые изменения**.

Вот примерно какое свойство зависимости мы хотели бы иметь: если A не зависит от B, то никакое изменение B не может повлиять на A. Однако что если **изменение B вносит зависимость (например, добавляются обращения к глобальной переменной)?** В результате мы приходим к тавтологическому определению с внутренним противоречием: "если A не зависит от B, то никакое изменение B не может повлиять на A... если только это изменение не вносит зависимость". Пытаясь избавиться от этого противоречия, придётся пойти на компромисс: что если иногда мы будем исключать подобные изменения, а иногда нет? Или, другими словами, любое прикладное обсуждение зависимости должно (неявно) нести в себе некоторую систему отсчёта, а какие вообще виды изменений будет "разумно" рассматривать? Когда вы спрашиваете, зависит ли стабильность вашего приложения от аналитического фреймворка, вы должны получить разный ответ в зависимости от того, интересуетесь вы тем, может ли изменение API привести к тому, что ваш код вызовет исключение, или же вас интересует, может ли кто-то воспользоваться уязвимостью и взломать телефон вашего клиента.

В дополнение к исполнительной модели и интересующих нас свойствах, подобное "пространство разумных изменений" становится третьим параметром, определяющим понятие зависимости. Иногда это будет уровень спецификации: мантра "зависеть от интерфейсов, а не от реализаций" означает, что если ваша программа использует функцию, то любое изменение реализации этой функции в пространстве "изменений, не меняющих спецификацию" не должно изменить корректность использования вашей функции. Таким образом, "пространство разумных изменений" вполне можно было бы назвать спецификацией.

Увы, но это скорее введёт нас в ещё большее заблуждение, потому что если вы спросите "могут ли авторы библиотеки XYZ испортить мне проект, изменив её интерфейс?", то на самом деле вы спрашиваете о возможных изменениях в уже существующей спецификации внешней библиотеки. В этом случае пространство допустимых изменений фактически становится **спецификацией спецификации**, и поэтому лучшее название, которое можно придумать для этого - это **"супер-спецификация"** (ограничения на допустимые изменения спецификаций...). 

Теперь мы можем полностью разобраться с проблемой зависимости фреймворка: запретить задачи, которые долго не завершаются. А для зависимости краша - запретить изменения, которые приводят к краху компонента (или как минимум, ощутимо влияют на их работу).

С зависимостью перебрасывания чуть сложнее. Интуитивно мы понимаем, что успех прохождения платежа зависит от платёжного процессора, который был фактически использован. Но если единственное, к чему приводит какое-то "собственное", внутреннее изменение (состояния) этого процессора - это выход его из строя, то никакое его подобное изменение не сможет остановить прохождение платежа, потому что система просто будет использовать другой платёжный сервис. То есть теперь мы можем сказать, что если у нашей системы есть запасной компонент для всего (что указано в спецификации), то у нее нет зависимостей!

На более высоком уровне абстракции мы по сути задаём вопросы типа "Я использовал это, но у меня было и другое, так нужно ли мне это (или то) на самом деле?". Это похоже на то, о чём любят разговаривать философы, и это мы обсудим отдельно. 
