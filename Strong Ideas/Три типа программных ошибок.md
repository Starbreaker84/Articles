## Три типа программных ошибок
Любая система может сломаться: пользователь введёт неверные сведения, данные в базе окажутся некорректными, откажет сеть или интернет, проявятся обычные баги, в параллельных процессах возникнет клинч или гонка, космические лучи инвертируют бит, и т.д.

И тем не менее, Марк Симан (известный ИТ-консультант, ИТ-архитектор, автор отличных книг, переведённых на русский: "Внедрение зависимостей в .NET" и "Код, который умещается в голове", рекомендую), предлагает такую классификацию ошибок:

**1. Предсказуемые ошибки, с которыми мы можем справиться.</br>
2. Предсказуемые ошибки, с которыми мы не можем справиться.</br>
3. Непредсказуемые ошибки.**

Многие ситуации с ошибками предсказуемы. Например, все вводимые данные следует считать подозрительными, и таковыми будут вообще все данные, получаемые "извне" системы. Корректным решением проблемы будет продуманная валидация данных.

Другой предсказуемый вид ошибок - недоступные сервисы (обсуждали этот момент в разборе видов зависимостей). Например, практически всегда можно предсказать, что рано или поздно ваша база данных окажется временно недоступной. Возникнет сбой сети, сисадмин неправильно настроит строку подключения, переполнятся журналы, откажет физический сервер, пройдёт DDOS-атака и т.д.

Есть сценарии, которые происходят с такой вероятностью и решение которых настолько хорошо известно, что они попадают в категорию предсказуемых ошибок, с которыми вы можете справиться. Пользовательский ввод относится к этой категории. Вы изучаете вводимые данные и сообщаете пользователю, если они "недействительны".

Но если вместо системы с UI вы пишете пакетное задание, которое каждую ночь обрабатывает большой файл данных? Как в этом случае поступать с некорректными данными? Отвергнуть весь набор данных? Отфильтровать его так, чтобы обрабатывать только корректную информацию? Или, может быть, вы асинхронно сообщите отправителю данных, что входные данные некорректны?
##
Другой пример: вы пишете код, который обращается к базе данных, считывает из неё информацию, и что-то с ней делает. Если ваша система зависит от базы данных, то предсказуемой ошибкой будет недоступность базы данных. Но сможете ли вы справиться с такой ситуацией?

Это классическая зависимость, которую мы разбирали в отдельных материалах.

Вы можете повторить операцию несколько раз, зафиксировать проблему в логах или уведомить кого-то ответственного. Но в любом случае система зависит от базы данных. Если база данных недоступна, система не сможет работать. Вы не можете справиться с этой проблемой, поэтому она попадает в категорию предсказуемых ошибок, с которыми вы не можете справиться.

Или нет?

Вы можете повторить попытку несколько раз, но вы не можете повторять и повторять слишком долго. В конечном итоге вам придётся признать, что операция обращения не отработала как ожидалось.

Скорее всего вы выбросите исключение, которое будет обработано "глобально" - где-то на высших уровнях, где скорее всего уже не получится сделать ничего другого, кроме как показать клиенту сообщение об ошибке, и остановиться или вообще закрыть программу.

Однако немало ситуаций, когда такое отношение к ошибкам неприемлемо. Если вы работаете с медицинскими системами жизнеобеспечения или космическими аппаратами, или в других контекстах с высокой ценностью, что же тогда делать?

Вы можете попытаться решить эту проблему известными приёмами программной инженерии: организовать отказоустойчивую базу данных, поставить по две сетевые карты в каждую машину, и т. п. Вы также можете подумать об изменении архитектуры системы.

Вы можете перейти на асинхронную систему, в которой сообщения поступают в очереди с длительным хранением. Конечно, и они тоже могут выйти из строя (всё может выйти из строя), но если всё сделано правильно, они, как правило, более надёжны. Даже машина, потерявшая связь с сетью, будет хранить сообщения в очереди на локальном диске до тех пор, пока связь не восстановится. Да, диск может быть переполнен и т. д., но вероятность этого меньше, чем отказ сети или недоступная база данных.

И теперь недоступная база данных попадает в категорию ошибок, которые вы предсказали, и с которыми можете справиться. (С другой стороны, невозможность отправить асинхронное сообщение теперь становится новым видом ошибки в вашей системе: та, которую вы можете предсказать, но с которой не можете справиться.)

Такое изменение, однако, влияет на архитектуру. Вы больше не можете использовать "прямой" метод интерфейса, обращающийся к базе, потому что вы не можете полагаться на то, что он корректно отработает в разумное время. В реальных сценариях сообщения об ошибках могут храниться в очередях часами, а то и днями, и блокировать такой код нельзя. Поэтому такое решение требует особого подхода к проектированию, отличного от того, когда вы предполагаете, что база данных доступна всегда.
##
Но должны ли вы всегда проектировать системы таким образом? Нет, конечно. Чтобы просто заставить асинхронный обмен сообщениями устойчиво работать, потребуется учесть множество дополнительных сложностей: UX, неупорядоченные сообщения, мёртвые очереди, версионирование сообщений и т. д. Добиться пяти девяток в асинхронщине обычно получается слишком дорого, и часто такие вложения неоправданны.

Суть скорее в том, что **то, что попадает в категорию предсказуемых ошибок, с которыми мы не можем справиться, не фиксировано, а зависит от контекста**. Возможно, нам следует назвать эту категорию предсказуемыми ошибками, которые мы решили не обрабатывать.

А как насчет третьей категории ошибок - тех, которые мы не смогли предсказать? По определению, мы узнаём о них только тогда, когда они проявляются. Однако **как только они становятся очевидными, то тут же попадают в другую категорию**. Кроме того, если ошибка возникла однажды, она может возникнуть снова. Теперь вам предстоит решить, что с ней делать.

Лучше всего, конечно, рассматривать ошибки как проблемы, не терпящие отлагательств, и немедленно их устранять. С другой стороны, вы можете отнести их к категории предсказуемых ошибок, с которыми вы решили не справляться.

Мы не пишем ошибки намеренно; они всегда будут присутствовать, а известные методы программной инженерии помогают сократить их количество: TDD, ревью кода, тестирование на основе свойств, ну и конечно правильное проектирование "как можно раньше".
##
Но к чему были все эти размышления об ошибках?

Самая простая рекомендация: добавляйте **всегда** немного предварительного и немного заключительного обдумывания кода, который вы пишете, делая **сознательный** акцент на предсказании возможных ошибок с учётом их классов.
