Симпатичное выступление ["Beyond PEP 8 - Best practices for beautiful intelligible code - PyCon 2015"](https://www.youtube.com/watch?v=wf-BqAjZb8M).

*Я заинтересовался им потому, что там говорится: "Distillation of knowledge gained from a decade of Python consulting, Python training, code reviews, and serving as a core developer. Learn to avoid some of the hazards of the PEP 8 style guide and learn what really matters for creating beautiful intelligible code."*, а я стараюсь выискивать подобные материалы, ну и вообще они встречаются весьма редко.

В частности, [Raymond Hettinger берёт 20-строчную программу на Python и затем показательно рефакторит её до 3 строк](https://gist.github.com/Maecenas/5878ceee890a797ee6c9ad033a0ae0f1).

"Сколько людей занялись бы рефакторингом такого кода?" - риторически вопрошает он, и затем посвящает остаток выступления тому, как работает этот трёхстрочный код.

Но недостаточно знать, как провести подобный рефакторинг. Наша цель в другом: **сразу писать подобный хороший компактный код! вам нужно стать именно одним из таких**.

Второй из его рефакторингов немного отличается от первого, поскольку ему также пришлось изменить API. Есть несколько простых эвристик, которые могут подсказать вам, какие изменения он сделал. Если вы проходили мои курсы по алгоритмам (или даже "28 задач"), то вероятно получали от меня code review, где **я заругал вас за вкладывание циклов в ветки условий :)**

И на Ясном коде вы наверняка запомнили, что **желательно выбирать короткие и наглядные имена для переменных**.

Ещё одна классическая рекомендация: **выполнять итерацию над коллекциями вместо прогона по индексам массива**. Однако ей часто злоупотребляют, потому что нередко требуется знать относительное положение элемента внутри такой коллекции, и вместо того, чтобы перейти к обычному циклу, программисты начинают городить жуткие конструкции. Тут засада в том, что итерация коллекции на самом деле пример более общей операции, называемой **"слияние" (fusion)**, которой тоже надо уметь грамотно пользоваться. Ну и также это сам по себе неплохой пример **инкапсуляции информации**: скрыть тот момент, что элементы таблицы маршрутизации доступны напрямую по индексу.

Однако крупный рефакторинг тут был выполнен переходом от управляющей структуры try-except-else-finally к простой инструкции with. В программной инженерии такой переход могут ошибочно называть и композицией, и декомпозицией, и рефакторингом, а по взрослому, это **факторизация** (разложение/удаление) **общих подвыражений**, когда например в выражении sqrt(x*x + y*y) повторяющееся возведение в квадрат мы выносим в отдельную функцию. Когда надо применять такой примитивный "DRY", обычно видят многие программисты, однако резко меньше (в десятки, а то и сотни раз) тех, кто понимает, что не менее важно тут использовать конструкции вида
```
getRoutingTable();
... что-то делаем ...
releaseRoutingTable();
```
Тут мышление уже происходит в формате выделения в коде функции, в идеале, высшего порядка (чтобы передавать ей не "конфигурационные" данные, которые надо дополнительно обрабатывать, а функции с нужной логикой обработки). Это **факторизация**, если можно так выразиться, **супер-выражений**, и когда возникает потребность в ней, это флажок, который вы должны учитывать, когда видите код наподобие примера Хеттингера.

Наверное, пока плохо понятно, что имеется в виду :)

Вот более простое инженерное объяснение: явное выделение логики инициализации и финализации - хорошо известный в программировании простенький паттерн, но в данном случае можно спросить, а зачем так вообще делать, если getRoutingTable() будет вызываться только один раз? Дело в том, что структура управления try-except-else-finally сама по себе - часто повторяющийся синтаксический шаблон, который призвана **абстрагировать** конструкция with. Мы получаем такую компактность не просто переходом от одной синтаксической конструкции к другой - мы получаем её за счет более сильной абстракции, это важно понимать прежде всего.

А **явное разделение логики захвата и освобождения некоего ресурса от кода обработки этого ресурса** - весьма частая закономерность, встречающаяся во многих языках, и ей всегда полезно следовать по множеству причин.

Между прочим, интерфейс [AutoCloseable](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) из Java 7, методы наподобие [File.open в Ruby](https://ruby-doc.org/core-2.2.0/File.html#method-c-open), паттерн [RAII](https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization) в Rust и C++, и даже [хаскелевская bracket](https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Exception-Base.html#v:bracket) - это всё один и тот же мета-паттерн, впервые реализованный как макро [with-open-file](http://clhs.lisp.se/Body/m_w_open.htm) в Common Lisp в 1980-х.

**Ищите общие структуры управления и абстрагируйтесь от них**. На самом деле таких шаблонов не так уж много, в СильныхИдеях постепенно их выкладываю. Усвойте эти принципы, и у вас появится внутренняя сила, которая не позволит вам писать плохой код, и вы будете блистать на code review - если только вы не попадёте ко мне :) Я бы настоял на том, чтобы вы прежде всего исправили жёстко закодированный IP-адрес (мой курс Ясный код в помощь). 
