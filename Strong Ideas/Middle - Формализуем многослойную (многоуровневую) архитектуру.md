Что такое многослойная (многоуровневая) архитектура (МУРА :) формально?
([в дополнение к этому посту](https://vk.com/wall-152484379_3546))

Современные системы слишком сложны, чтобы можно было вот так просто взять и спроектировать и разворачивать их в многослойной архитектуре без глубокого её понимания. Я сейчас дам вам достаточно простую **формальную модель слоистой архитектуры**, которая представляет её весьма наглядно, и при этом может масштабироваться до огромных размеров.

Всегда думайте о слоистой архитектуре как о **направленном ациклическом графе** (вспоминайте второй курс по АСД), и проектируйте её в соответствии с правилами его построения. Пытаться представить систему как рекурсивную схему вложенных друг в друга под- и подпод-систем - это катастрофа. Не делайте этого. Думайте о таких подсистемах и связях между ними как об узлах и ветвях в ациклическом направленном графе (диграфе).

В архитектуре МУРА единственным допустимым обращением к некоторой сущности, реализованной в более высоком слое, считается **асинхронное событие, происходящее на более низком уровне**. Однако объявление и документация этой сущности должны находиться в интерфейсе нижнего уровня (сам по себе он к нему не может обращаться - да и незачем ему; отсутствует реализация, ну или заглушки стоят, или исключения генерируются), чтобы и любые верхние слои могли ей правильно манипулировать, и, главное, обеспечивается повторное использование нижнего слоя.

Имеется в виду, что **вы всегда можете задеплоить любые M подряд идущих нижних слоёв вашей системы из N слоёв, без необходимости разворачивать верхние**.

Критерием истинной МУРА становится тот факт, что **сущности верхнего уровня могут быть объявлены в терминах - и реализованы только с помощью - сущностей, объявленных в этом же уровне, или в нижних**. Под сущностью подразумевается функция, класс, тип, переменная...

**Строгая слоистая архитектура** - когда допустимыми к использованию для объявления сущностей в некотором слое становятся сущности, доступные **либо в данном слое, либо непосредственно в одном низлежащем**. Таким образом, вместо того, чтобы называть подсистему "слоем", мы можем называть её узлом. Если слой A зависит от непосредственно нижнего слоя B, то соответственно существует направленное ребро от A к B (обратите внимание на направление ребра). Таким образом мы и получаем то, что математики веками называют направленным графом. И теперь потребуйте от всех разработчиков, чтобы никто не искажал пространство проекта кривым кодом, в котором слой А волшебным образом оказывается **И выше, И ниже слоя B** - то есть в проекте не должно быть циклов, и мы получили направленный ациклический граф. Вот так мы обобщили понятие многоуровневой архитектуры до чего-то такого, что масштабируется до произвольно больших систем, но при этом обладает всеми исходными желаемыми свойствами.

Почему можно утверждать, что этот подход легко масштабируется? Вы всегда можете придерживаться той самой популярной и удобной, но формально не обоснованной и потенциально приводящей к запутыванию схемы, подразумевающей складывание системы из подсистем, - **объединять набор подсистем в пакеты, которые станут новыми узлами, а зависимости между этими пакетами - новыми ребрами**.
Самое главное: делать это аккуратно и правильно, чтобы такой новый граф как подсистема также был ациклическим. 
