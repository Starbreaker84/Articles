Сколько раз вы пытались удалить некоторую зависимость из проекта, но не были уверены, что сделали это успешно?

Чтобы ваша кодовая база не зависела от чего-то конкретного?

Или чтобы она "зависела от интерфейсов, а не от реализации"?

Или старались следовать SOLID по инверсии зависимостей?

Удаление зависимостей - безусловно нетривиальная тема, по ней будет несколько крупных материалов, и когда вы их изучите, то получите объективное определение зависимости в программной инженерии и методы избавления от неё. Оно включает все моменты, которые разработчики упоминают в связи с зависимостями - от управления пакетами до тюнинга производительности и даже до юзабилити, и при это оно будет достаточно строгое, чтобы вы могли проверять его "механически".

Говоря "механически", я не имею в виду, что это будет автоматизировано, или даже что это будет просто. Относительно легко написать такую функцию, когда чтобы просто понять, может ли она взаимодействовать с другой функцией, потребуется решение крупной математической проблемы. Однако с тем новым пониманием зависимостей, которое я вам дам (плюс с некоторым количеством ваших собственных размышлений по теме), вы сможете точно объяснить, что это значит и что нужно сделать, когда вам например нужно будет убедиться, что приватность пользователя не зависит от сторонней библиотеки.

Если вы программист, то, скорее всего, вы занимались подобным не раз. И если вы занимались этим уже некоторое время, то велика вероятность, что у вас возникали сомнения по поводу того, успешно ли вы это сделали.

Зависимость - это одно из тех слов, о которых все думают, что хорошо знают, что оно означает (в "Чистом коде" Боб Мартин использует это слово более 100 раз, не давая ему определения). Но как бы ни было легко и просто разглагольствовать об ограничении зависимостей, неопределённость в том, что это значит, приводит к неопределённости в реальной работе.

Для программистов тема зависимостей встречается постоянно, и особо "любима". Например, типичное высказывание: "мой проект включает PostgreSQL в качестве зависимости, но он не зависит от него, если эта база данных не используется, и фактически он и не зависит от него, потому что мой проект не зависит от базы данных". Если вы задумаетесь над этим предложением, то окажется, что каждое использование слова "зависеть" имеет тут разное значение. Мы знаем, что ограничение зависимостей - это хорошо, но без реального понимания, что это значит, это совет, обречённый на провал.

Я предлагаю вам строгое определение зависимости, которое было сформулировано несколько лет назад на научных конференциях по computer science; с его помощью вы можете однозначно (хотя это будет не всегда возможно) понять, удалось ли вам устранить зависимость в проекте. При попытке применить подобные определения возникает много тонкостей, но учёные обнаружили, что их можно решить, основываясь на вычислительной философии (да, есть и такая).

Начнём мы однако с того, почему тема зависимостей сложна. 

Вы разрабатываете мобильное приложение для Андроида, добавляете в него стандартную аналитическую механику сбора статистики от Google, но чтобы не "зависеть" от конкретного сервиса, делаете отдельный уровень абстракций, чтобы смена подобной механики была простой. Зависит ли ваше приложение от гугловской аналитики?

(пауза)

Мартин Фаулер (которого я крайне не рекомендую чиать :) заявляет, что такую зависимость можно устранить, добавив метод-делегат на сервер, который (сервер) скроет этот делегат. Роберт Мартин однако утверждает, что если что-то в вашем проекте логически зависит от реализации (как подобный уровень абстракции), значит, имеется и физическая зависимость - видимо, имея в виду, что если что-то важное зависит от вашего выбора аналитического фреймворка, то на это имеется ссылка непосредственно в тексте программы. Однако тут имеется некоторое противоречие: один говорит, что слой абстракции аналитики устраняет зависимость, и намекает, что это хорошо, а другой утверждает, что это плохо. Это довольно интересное противоречие от коллективного Роберта Мартина Фаулера; оба они довольно близкие по духу гуру в программной инженерии. Но действительно ли они на самом деле говорят о том, что скорее относится к проблеме с существующей терминологией?

Я уже упоминал книгу Джона Оустерхаута " A Philosophy of Software Design" (на русский, к сожалению, не переведённую), где автор очень аккуратно обходится с понятием зависимости. И вот какой пример он приводит:

*"На одном старом веб-сайте, где фон задавался отдельно на каждой странице, все веб-страницы были зависимы друг от друга".*

Вроде бы это неочевидно, и даже может показаться, что веб-страницы наоборот независимы друг от друга, так как фон для каждой из них задаётся отдельно? Дело в том, что зависимости - это часто действительно головоломки, паззлы, решение которых обычно совсем не очевидно.

Чтобы как следует понять, что такое зависимость, порешайте следующие задачки. 

1 - **Зависимость фреймворка**. Мы обычно думаем, что если A вызывает B, то A зависит от B.

Но возьмём классический планировщик раунд-робин: он рано или поздно вызовет каждую задачу, которая была запланирована. Но зависит ли он от каждой из задач?

2 - **Зависимость расшаренного формата**. Если A корректно записывает информацию в файл, а B корректно считывает её, то они явно связаны друг с другом хотя бы из-за общего формата данных в файле. Но кто из них от кого зависит?

Другая схожая ситуация, когда клиент посылает сообщения на сервер по API; если один из них изменит формат сообщений, другой сломается. Зависят ли они оба друг от друга?

3 - **Зависимость зависимости**. Нам нравится (ошибочно) думать, что если A не зависит от B, то изменение B не может повлиять на A.

Но что если вы измените B таким образом, что появится новая зависимость? Например, если вы измените глобальную переменную, которую использует A? 

4 - **Зависимость краша**. Более экстремальный вариант предыдущего: изменение любого модуля через косвенные связи может повлиять на изменение любого другого модуля (в частности, привести к краху программы). Таким образом, если придерживаться правила "A не зависит от B, если изменение B не может явно повлиять на A", то получим в итоге прямо противоположное: всё зависит от всего остального.

5 - **Зависимость перебрасывания**. Сайт загружает ресурс по CDN, но в случае её недоступности обращается к конкретному серверу; приложение использует дешевый, но нестабильный платежный сервис, когда это возможно, но переключается на более надёжный, но более дорогой, когда первый не работает; аналитический сервис пытается подключиться к нескольким серверам, пока не найдет подходящий; медиаплеер, использующий аппаратное декодирование, когда оно доступно, или программное, когда аппаратного нет - все они имеют структуру "A использует B, но переходит к C".

Во всех этих случаях отказ B не означает отказа A. Но значит ли это, что A не зависит от B?

6 - **Зависимость инверсии**. Инверсия зависимостей из SOLID рекламируется массам якобы в целях устранения зависимостей: вместо того, чтобы A статически связывал/вызывал модуль B, программа передает A ссылку на B во время выполнения. Но A всё равно откажет, если откажет B. Ну и? Вдобавок, в DI мы теряем множество полезных проверок статического тайп-чекинга. 

7 - **Зависимость зацикливания**. Обычно мы считаем зависимость транзитивной: A не может функционировать без B, а B не может функционировать без C, поэтому A не может функционировать без C.

Мы также жалуемся на циклы зависимости: A зависит от B, а B зависит от A - это плохо, но такое может случиться.

Теперь соединим всё это вместе: что это вообще значит для А - зависеть от А?

8 - **Зависимость высшего порядка**. Библиотеки не должны зависеть от кода приложения, в котором они используются. Но как минимум в одном случае (который вы сами можете легко обобщить), они явно от него зависят: реализация хэш-таблицы будет давать неправильный результат, если разные ключи (например, объекты из некоторой иерархии) противоречиво реализуют методы сравнения и вычисления хэша - то есть, когда одинаковые значения выдадут разные хэш-коды. Те же строки - это в известных языках программирования не базовые типы, а классы, и вы вполне можете создать их наследника, переопределяющего какой-нибудь equals(), и затем пихать в хэш-таблицу и стандартные строки, и ваши переделанные. Так зависят ли хэш-таблицы и многие другие стандартные библиотечные классы от вызывающего их кода? 

9 - **Зависимость большинства**.

Интересно, вам рассказывали в университете на информатике (если вам вообще повезло там учиться :) про "N-version programming" из 1970-х? Тогда эта идея была модной: если 5 человек пишут одну и ту же программу, то вероятность, что во всех их версиях кода будут одни и те же ошибки, исчезающе мала, верно? Мы берём, конечно, профессиональных разработчиков; так то у меня на курсе с нуля 98% начинающих делают одни и те же ошибки :)

Таким образом, вы можете попросить 5 программистов реализовать одну и ту же (очень подробную) важную спецификацию (например, для управления АЭС), и пусть сами программы голосуют, что им делать на каждом своём шаге выполнения; до тех пор, пока три человека не сделают одинаковых ошибок в спецификации (что крайне маловероятно), программа всегда будет работать в соответствии со спецификацией, верно?

Увы нет; это классический когнитивный баг, незнание механизмов статистики, которые часто выдают совершенно неочевидные результаты.

[Вот](https://ieeexplore.ieee.org/document/6312924) эмпирическое опровержение данной методики. По одной и той же спецификации было подготовлено 27 (!) версий программы, совершено независимо, в двух разных университетах, после чего они были прогнаны через миллион тестов. Результаты показали, что хотя по отдельности программы были чрезвычайно надёжны, однако количество тестов, в которых не сработало более одной программы, было значительно больше, чем ожидалось.

В контексте зависимостей тут возникает интересный парадокс: предположим, что все 5 подсистем управления АЭС реализуют спецификацию идеально, и поэтому все пятеро всегда голосуют за одно и то же действие. Тогда никакие изменения в любой отдельной реализации не могут изменить поведение всей системы. Но разве можно сказать, что она не зависит ни от одной из пяти программ?

---

Мы рассмотрели 9 видов зависимостей, которые вам всегда надо иметь в виду при разработке системы абсолютно любой сложности.

Далее более подробно разберёмся, как правильно понимать вопрос "Зависит ли А от B?", и что из такого понимания следует в плане повседневной практики. 
