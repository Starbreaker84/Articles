Формальная чистота кода в функциональном программировании возведена в ранг святой темы. Действительно, чистые функции не имеют побочных эффектов, соответствующий код хорошо параллелится и легко тестируется, он модульный, он может многократно использоваться, и вообще магически спасает от 108 типов проблем. Однако платой за это становится тот факт, что код программы распухает и начинает занимать всё больший объём.

На практике, как обычно, определённые инженерные компромиссы нередко дают ощутимую полезную выгоду, а жертвовать приходится подчас совсем малым. В частности, можно отказаться от полной частоты, и разрешить стать функциям **"немножечко грязными"** (или, более корректно, **"слабо чистыми" - weakly pure**). Ключевой момент, что у этой "грязи" в computer science есть хорошие формальные обоснования, то есть пачкать функцию надо правильно.

Слабо чистой функции разрешается:
- изменять свои аргументы (или их атрибуты), если они передаются по ссылке;
- читать из глобального состояния.

**Единственное, что слабо чистой функции запрещается: изменять глобальные состояния**.

Таким образом мы сохраняем и модульность, и выразительность, и тестируемость кода.
Может показаться, что изменение аргументов и изменение глобального состояния - это примерно одно и то же, но нет.

Например:
```
startMusic();
...
stopMusic();
```
Эти функции явно как-то изменяют неведомое глобальное состояние, и также очевидно, что корректность работы зависит от порядка их вызова. Причём stopMusic() может располагаться далеко ниже в коде модуля с комментарием наподобие "Завершить приём музыки по сети" (что так и просится на отдельный метод shutDownMusicNetwork).

Далее вы просматриваете код и обнаруживаете, что эти два вызова находятся на семи уровнях вложенности друг от друга, и никакой промежуточный код не может быть безопасно удалён.

Если же мы решим использовать слабо чистую функцию, то ситуация, на первый взгляд, изменится не сильно:
```
startMusic(my_track);
...
stopMusic(my_track);
```
Подразумевается, что объект my_track передаётся по ссылке.

Однако теперь наглядно видно, что эти две функции влияют друг на друга. Существует явная зависимость потока данных во втором вызове от первого. Теперь странно будет разнести их на разные уровни вложенности, причём это скорее всего и не будет возможно, так как в обоих вызовах требуется доступ к my_track.

А лучше всего **запрещать ошибочные последовательности вызова методов на уровне компилятора**: используйте статические типы, чтобы обеспечить соблюдение порядка. Пусть например `startMusic()` возвращает объект специального типа, который требуется параметром в `stopMusic()`. 
