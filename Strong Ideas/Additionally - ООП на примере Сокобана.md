## Сокобан

Вариаций сокобана множество, мы рассмотрим чистую классическую версию: есть только стены, ящики, герой, и целевые точки, куда надо ставить ящики. Остальные дополнения вводятся в игру типовыми способами, аналогичными описываемым далее.

Программирование UI - отдельная большая тема, касаться её не будем. Подчас программирование красиво и удобно работающего UI может быть существенно сложнее, нежели программирование самой игровой логики (этой теме UI посвящён один из курсов по парадигмам программирования).

Ограничимся в учебных целях символическим выводом игрового поля в текстовом виде (сам проект реализовывается на C# в Visual Studio 2019).

Классические игровые движки обычно взаимодействуют с игровой логикой, игровой графикой и UI через вызовы двух методов (названия условны): Logic и Render. Они вызываются автоматически, а параметром, как правило, передаётся количество миллисекунд, прошедших с их последнего вызова. Так, в частности, работает популярный движок Unity3D, где программирование ведётся на C#.

Logic подразумевает, что случился следующий игровой "шаг" логики (внутри этого метода мы и определяем собственную логику нашей игры). По большому счёту, Logic актуален только для игр реального времени, в нашем случае его можно игнорировать. Однако Logic требуется и для других целей - отслеживать и обрабатывать действия пользователя (клавиатурные команды).

Render подразумевает отрисовку на экране всех изображений и элементов UI (выводится очередной кадр). Мы будем просто обновлять текстовое представление игрового поля в стандартной Label на форме. В случае полноценной игры надо учитывать например такие нюансы, как большое игровое поле, выходящее за пределы экрана, с умной прокруткой: когда двигаем героя, показываемая часть игрового поля аккуратно центрируется относительно его позиции, и т. п.

Кроме того, не будем специально контролировать выход героя при движении ящиков за границы игрового поля: подразумевается, что каждый уровень спроектирован так, что это невозможно (между краем экрана и свободным игровым пространством имеется достаточно непроходимых клеток). 

### 1. Анализ

Явные игровые сущности сокобана - это **Герой** (всегда один), **Пол** (по нему можно передвигаться), **Стена** (непроходима), и расставленные на полу (визуально видимые на игровом поле) **Ящики**. Кроме того, надо отслеживать размещение ящиков на целевых клетках, которые пусть и будут таковой сущностью как **Цель**.

Чуть менее очевидная вещь - само **Игровое поле**, на котором хранятся различные элементы. Оно всегда одно. Почему оно менее очевидно? Потому что в реальном мире такой физической сущности не существует (это просто абстрактная концепция). А зачем оно вообще нужно? Потому что в программе требуется явный контейнер (массив) для хранения элементов пола и ящиков.

Важный нюанс, что на игровом поле могут находиться как статические элементы (стены, пол), которые вдобавок могут быть как проходимыми, так и непроходимыми, так и динамические (герой, ящики); динамические объекты располагаются "поверх" статического пола, как и в реальном мире, и будут "упираться"в непроходимые стены и упираться в ящики или двигать их. 

Уже гораздо менее очевидная сущность, но это фактически паттерн - сама **Игра** (она тоже единственная). Зачем она нужна? Во-первых, игровым миром должен "кто-то" управлять (обрабатывая например нажатия клавиш человека и выполняя манипуляции с игровым полем). Во-вторых, по командам UI наподобие "новая игра" или "завершение игры" надо выполнять начальную расстановку игрового поля, а также учитывать игровую статистику, переходить к следующему уровню, сохранять и загружать игру и т. п.

В нашем условном примере Logic и Render будут принадлежать Игре, и их простейший вызов реализуем по таймеру формы через 0,5 секунды.

Допустим, мы хотим также вести минимальную статистику: сколько уровней игры пройдено, и текущее и суммарное количество баллов. Такую **Статистику** естественно будет выделить в свою сущность (тоже единственную, так как герой всегда один).

В полноценных игровых проектах часто ещё требуется **Сцена** (или Экран). Между непосредственными игровыми сессиями возможны различные промежуточные игровые состояния (меню настроек, экран вывода бонусов и статистики, инвентарь, карта и т. п.). Все такие экраны подразумевают явное существование в программе, так как сильно различаются своей внутренней логикой взаимодействия с пользователем. В нашем простом случае обойдёмся без дополнительных сцен: экран всегда показывает только игровое поле со всей дополнительной информацией, и всегда целиком.

Почему важно обращать внимание на единственность тех или иных сущностей? Потому что они удобно реализуются в проекте паттерном Синглтон (проще всего - в виде статического класса), существенно сокращая код. Такие синглтоны - фактически глобальные переменные в проекте, но это нормально, так как они концептуально в игре всегда единственны и всегда везде доступны (игра фактически строится вокруг них). Главное - аккуратно определить допустимый набор операций над ними.

На этом этап анализа завершён.

### 2. Проектирование и (частичная) реализация

Основному классу Игра дадим название GameEngine (по поводу этого названия имеется немало мемов :) и сделаем его статическим (синглтон). Сразу добавим метод Render, и оформим его вызов из обработчика таймера.

По нажатию единственной кнопки выполним начальную инициализацию Игры и запустим таймер. 

```
private void btnStart_Click(object sender, EventArgs e) {
    GameEngine.Init();
    timer.Enabled = true;
}
```

Что будет представлять собой игровое поле (класс Board)?

Классический подход, когда вполне достаточно обойтись двумерным массивом, хранящим статические (в смысле неподвижные) игровые объекты. Полиморфно храним на поле универсальные объекты (класс Item), от которых наследуем пол (два вида: обычный и целевой, куда надо двигать ящики) и стену, а также некоторый "пустой" объект (пустота за пределами стен игры), чтобы не использовать для этого null (всегда плохо!).

Но эта "наивная" схема, которой часто придерживаются начинающие, имеет существенные минусы, которые мы разберём чуть дальше.

От класса Board мы хотим, во-первых, универсальный метод генерации игровой расстановки по номеру уровня - Generate. Как может быть организован этот метод? Делать внутри него огромный switch/if else по уровням крайне плохой стиль. С другой стороны, создавать под каждый уровень отдельный класс в нашем простом случае тоже излишество.

Хороший способ - описывать уровни декларативно; придумываем для описания уровней сокобана свой микро-язык. Собственно, [всё уже давно придумано до нас](https://habr.com/ru/post/597857/).

Реализовать это можно так, что создаём синглтон Levels, который хранит список описаний уровней (его можно формировать программно непосредственно в коде, или грузить из файла), а Generate просто запрашивает у него нужный уровень по номеру, и затем парсит, превращая в расстановку элементов.

Но мы сейчас изучаем именно проектирование, поэтому не будем погружаться в технические детали реализации. Исключительно в демонстрационных целях выполним расстановку непосредственно в коде, в классе Board. 

```
public static class Board {
    public const int Width = 25;
    public const int Height = 15;
    
    static Dictionary<String, Item> Items;

    public static Point Generate(int level) {
        Items = new Dictionary<String, Item>();

        for(int x = 0; x < Width; x++) 
            for(int y = 0; y < Height; y++) Add(new None(),x,y);

        for(int x = 2; x < 20; x++)
            for(int y = 2; y < 10; y++) Add(new Wall(),x,y);

        for(int x = 4; x < 19; x++)
            for(int y = 4; y < 9; y++) Add(new SimpleFloor(),x,y);

        for(int x = 7; x < 12; x++)
            for(int y = 5; y < 7; y++) Add(new Wall(),x,y);

        Add(new TargetFloor(),18,6);
        Add(new TargetFloor(),18,7);
        Add(new TargetFloor(),18,8);

        BoxList.Add(9,7);
        BoxList.Add(12,7);
        BoxList.Add(12,5);

        return new Point(4,4);
    }

    internal static void Add(Item itm, int x, int y) {
        Items[ToKey(x,y)] = itm;
    }

...
}
```

Во-вторых, в Board требуется получение "графического" представления некоторой клетки (для отображения её на экране) - GetChar (просто символ, который будет обозначать соответствующий объект на экране). Подобное "смешивание" чистой игровой логики и рендеринга само по себе плохо, но если мы уверены, что "графика" игры будет точно только текстовой, использование GetChar более-менее корректно.

Так как у нас гарантированно текстовый "рендеринг", для простоты выполним генерацию текстового представления игровой доски непосредственно внутри Board (обычно это происходит в методе Render).

Однако тут надо находить важный компромисс при формировании текстового "экрана": если мы решаем хранить игровое поле "тупо" в виде двумерного массива, то придётся постоянно сканировать список из N ящиков при переборе всех клеток игрового поля (сложность O(H\*W\*N)) - чтобы понять, когда в очередной позиции надо показывать не пол, а ящик на нём.

Или можно хранить ящик непосредственно "внутри" каждого поля (как в реальном мире), в отдельном списке, что с другой стороны усложняет и структуру самого поля/клетки, и поиск каждого ящика. Тут как раз очень полезно делать оценки сложности с конкретными коэффициентами, чтобы сравнить их для конкретных схем игры. На практике может применяться оптимизированная схема (зависящая от конкретной игры), когда игрового поля как хранилища объектов в виде двумерного массива вообще нету.

Гораздо более продуктивно реализовать поле в виде словаря. Координаты x,y выступают в виде ключа (например, приведением к строковому виду), а сам объект становится их значение. В таком случае проверка наличия ящика в позиции x,y, а также его добавление в словарь, выполняются за O(1), и мы вдобавок избавляемся от двумерного массива и необходимости поддерживать его консистентность. 

```
internal static string ToKey(int x, int y) {
    return x.ToString()+"."+y.ToString();
}

public static string ToString(Point hero_pos, string hero_char) {
    string s = "";
    int w = Width;
    int h = Height;
    for(int y = 0; y < h; y++) {
        string current = "";
        for(int x = 0; x < w; x++) 
            if(x == hero_pos.X && y == hero_pos.Y)
                current += hero_char;
            else if(BoxList.IsBox(x,y))
                current += Box.GetChar(); 
            else
                current += Items[ToKey(x,y)].GetChar();
            s += current + "\n";
    }
         
    return s;
}
```

Классы пола и стен, которые фактически определяют только внешний вид соответствующей сущности на экране. 

```
public abstract class Item {
    public abstract string GetChar();
}

class None : Item {
    public override string GetChar() { return " "; }
}
    
class Wall : Item {
    public override string GetChar() { return "="; }
}

class TargetFloor : Item {
    public override string GetChar() { return "+"; }
}
    
class SimpleFloor : Item {
    public override string GetChar() { return "."; }
}
```

Сам герой и ящики - динамические объекты. Их поддержка в игре может быть организована по разному. В нашем случае используем самое простое решение. Герой - это класс Hero (синглтон, статическое поле, т.к. он заведомо один в игре), фактически только хранящий свою текущую позицию на доске. Его инициализация (помещение в нужную позицию игрового поля) выполняется в методе инициализации Init "движка" GameEngine, а начальная позиция вычисляется при создании очередного уровня в Board (метод Generate). 

```
class Hero : Item {
    Point pos;

    public Hero(Point p) { pos = p; }

    public Point GetPosition() { return pos; }
    public void SetPosition(Point p) { pos = p; }

    public override string GetChar() { return "@"; }
}
```

Обратите внимание, что мы наследуем героя от Item - так как он должен единообразно показываться на экране, как и другие элементы игрового поля. 

```
public static class GameEngine {
    static Hero SokoHero;

    public static void Init() {  
        Statistics.Init(true);
        BoxList.Init();
        SokoHero = new Hero(Board.Generate(1));
    }

    public static void Render(Label screen, Label info) {  
        string scr = Board.ToString(SokoHero.GetPosition(), SokoHero.GetChar());
        screen.Text = scr;
        info.Text = Statistics.toString();
    }

...
}
```

С ящиками ситуация немного сложнее - их может быть много, и они могут перемещаться, накладываясь на экране на статические поля игры. Однако плодить низкоуровневый код работы с каждым ящиком, да ещё и представляя ящик отдельным классом, нежелательно, это явное усложнение.

Тут подходит такой приём, что определим отдельный класс-коллекцию ящиков с универсальным набором простых операций (это наиболее правильный подход, который подробнее разбираем в материале "Быстрая прокачка в ООП").

Нам нужны методы добавления ящика в указанную позицию, перемещения ящика из одной позиции в другую, проверки, есть ли ящик в некоторой позиции, и получения символа ящика для представления на экране.

Очевидно, что непосредственно классу Ящик добавлять такие методы совсем неверно, тут явно нужно специализированное хранилище. Однако начинающие тут делают нередкую ошибку, когда вроде бы "естественно" создают класс Box, и потом начинают с ним сильно мучаться. Рекомендация такая, что если некоторые сущности потенциально оригинального типа существуют в программе во множественном числе, и ими надо как-то манипулировать, а методы такой сущности как-то явно для этого не подходят, то создаём отдельный класс-коллекцию с подходящим набором операций. 

```
static class BoxList {
    static HashSet<String> Boxes;

    public static void Init() {
        Boxes = new HashSet<String>();
    }

    public static void Add(int x, int y) {
        Boxes.Add(Board.ToKey(x,y));
    }

    internal static bool IsBox(int x, int y) { 
        return Boxes.Contains(Board.ToKey(x,y));
    }

    internal static string GetChar() { return "*"; }

    internal static void MoveBox(int xb, int yb, int xt, int yt) {
        if( ! IsBox(xb,yb) ) return;
        Boxes.Remove(Board.ToKey(xb,yb));
        Add(xt,yt);
    }
}
```

Внутри такой коллекции, как видно, никаких ящиков как физических объектов нету. Это просто множество ключей-позиций всех ящиков в игре, и всё. 

Основная игровая логика, по сути, сводится к одной операции: перемещению героя на одну из соседних клеток - с учётом, что в этом направлении мог быть ящик, который или можно двигать, или нет. Если ящик двигать нельзя, или там стена, значит, герой не перемещается. 

```
private static void MoveHero(int dx, int dy) {
    Point pos = SokoHero.GetPosition();
    if(! Board.IsEmpty(pos.X+dx, pos.Y+dy)) return;

    if(BoxList.IsBox(pos.X+dx, pos.Y+dy)) {
        bool is_empty = Board.IsEmpty(pos.X+dx*2, pos.Y+dy*2);
        if(BoxList.IsBox(pos.X+dx*2, pos.Y+dy*2) || ! is_empty) return;
        if(is_empty)
            BoxList.MoveBox(pos.X+dx, pos.Y+dy, pos.X+dx*2, pos.Y+dy*2);
    }

    SokoHero.SetPosition(new Point(pos.X+dx, pos.Y+dy));
    Statistics.Step(); 
}
```

*Логику для случая, когда на соседней клетке есть ящик, из соображений хорошего стиля лучше конечно выделить в отдельный метод :)*

Наконец, органзуем взаимодействие логики с действиями пользователя в методе Logic.

```
internal static void Logic(Keys key) {
    if(key == Keys.Left)  MoveHero(-1,0); else
    if(key == Keys.Right) MoveHero(+1,0); else
    if(key == Keys.Up)    MoveHero(0,-1); else
    if(key == Keys.Down)  MoveHero(0,+1);
    if(Board.GameFin()) {
        Statistics.IncScores();
        // .. pause
        Init();
    }
}
```

Он очевидным образом вызывается из формы при отпускании какой-либо клавиши (чтобы не было автоматического повтора нажатия): 

```
private void frmMAIN_KeyUp(object sender, KeyEventArgs e) {
    GameEngine.Logic(e.KeyCode);
}
```

Окончание игры проверяется в классе Board - все ли ящики размещены на целевых полях. 

```
internal static bool GameFin() {
    for(int x = 0; x < Width; x++) 
        for(int y = 0; y < Height; y++)
            if(CheckPosition(typeof(TargetFloor),x,y) && ! BoxList.IsBox(x,y)) return false;
    return true;
}

internal static bool CheckPosition(Type typ, int x, int y) {
    return Items[ToKey(x,y)].GetType() == typ;
}

internal static bool IsEmpty(int x, int y) {
    return CheckPosition(typeof(SimpleFloor),x,y) || 
           CheckPosition(typeof(TargetFloor),x,y);
}
```


### 3. Расширения

Класс Statistics потенциально отвечает за сбор игровой статистики - например, число шагов, сделанных для решения. Вы можете доработать его самостоятельно.

```
static class Statistics {
    static int TotalScores, CurrentScores, Steps;

    public static void Init(bool new_game) {
        if(new_game) TotalScores = 0;
        CurrentScores = 0; 
        Steps = 0;
    }

    public static void Step() { Steps ++; }

    public static void IncScores() {
        int add = 1000 - Steps;
        TotalScores += add;
        CurrentScores += add; 
    }

    internal static string toString() {
        return Steps + "\n" + CurrentScores;
    }
}
```

Подумайте также, как лучше реализовать сохранение/восстановление игры. Вам надо "сериализовать" все нужные значения в текстовый формат (позицию героя и ящиков и текущую статистику). Если расстановка на игровом поле генерируется случайно, тогда надо сохранять и её. 

---

Весь проект целиком (для VS 2019) вы можете [скачать тут](http://skillsmart.ru/self/work/sokoban.zip).
